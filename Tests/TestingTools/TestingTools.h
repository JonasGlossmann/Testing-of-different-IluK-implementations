//
// Created by jonas on 03.04.2025.
//

#ifndef TESTINGTOOLS_H
#define TESTINGTOOLS_H

inline MatrixTriple loadStandardTestingProblem() {
    DenseVector rhs(R"(../Tests/TestFiles/testing_Problem/p_rhs.mtx)");
    DenseVector x_0(R"(../Tests/TestFiles/testing_Problem/p_initial_guess.mtx)");
    MatrixTriple out(R"(../Tests/TestFiles/testing_problem/p_local_A.mtx)");
    out.rhs = rhs;
    out.startvector = x_0;
    return out;
}

//if calculating of a solution takes much time, the matrix can be saved for further testing
inline void exportToMTX(const std::vector<MatrixEntry>& entries, int rows, int cols, const std::string& filename) {
    std::ofstream file(filename);

    if (!file) {
        std::cerr << "Error: Could not open file " << filename << std::endl;
        return;
    }

    // Write the Matrix Market header
    file << "%%MatrixMarket matrix coordinate real general\n";
    file << "% Generated by C++ exportToMTX\n";

    // Write the matrix dimensions and number of nonzero elements
    file << rows << " " << cols << " " << entries.size() << "\n";

    // Write matrix entries (1-based indexing for .mtx format)
    for (const auto& entry : entries) {
        file <<std::setprecision(53)<< entry.row + 1 << " " << entry.col + 1 << " " << entry.value << "\n";
    }

    file.close();
    std::cout << "Matrix exported to " << filename << std::endl;
}

//loads a previously saved matrix created for testing
inline CSRMatrix load_matrix_from_path(const std::string& path) {
    return CSRMatrix(path);
}

void debug_assert(auto expected_value, auto actual_value, std::string message) {
    if (expected_value != actual_value) {
        std::cerr <<message << std::endl;
        assert(false);
    }
}

#endif //TESTINGTOOLS_H
